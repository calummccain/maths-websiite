<!DOCTYPE html>
<html>

<head>

    <meta charset="utf-8">

    <link rel="stylesheet" href="../../css/test.css">

    <title>first page</title>
</head>

<body>

    <a href="/root/index.html">index</a>

    <script type="module">
        import * as DATA from "../../js/data/polychorons/24-cell.js";
        import * as SPH from "../../js/maths-functions/spherical-functions.js";
        import * as THREE from "../../js/three.module.js"
        import * as VF from "../../js/math-functions/vector-functions.js";
        import * as SF from "../../js/math-functions/spherical-functions.js";

        var scene, camera, renderer;
        var object;
        var projectedVertices = [];

        var WIDTH = window.innerWidth;
        var HEIGHT = window.innerHeight;

        function init(cells, opacityValue) {

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121212);

            scene.add(new THREE.HemisphereLight(0xaaaaaa, 0x444444));

            var light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(1, -1, 1);
            scene.add(light);

            initObjects(cells, opacityValue);

            initCamera();
            initRenderer();

            document.body.appendChild(renderer.domElement);
        }

        function initCamera() {
            camera = new THREE.PerspectiveCamera(70, WIDTH / HEIGHT, 1, 10);
            camera.position.set(0, -5, 1);
            camera.lookAt(scene.position);
        }

        function initRenderer() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(WIDTH, HEIGHT);
        }

        function initObjects(cells, opacityValue) {

            var geometry = new THREE.Geometry();
            var material = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.8),
                roughness: 0.5,
                metalness: 0,
                flatShading: true,
                opacity: opacityValue,
                transparent: true
            });
            material.side = THREE.DoubleSide;

            for (var i = 0; i < 24; i++) {
                projectedVertices[i] = SPH.sphereToPoincare(DATA.vertexDict[DATA.vertices[i]], 2);
                geometry.vertices.push(
                    new THREE.Vector3(
                        projectedVertices[i][0],
                        projectedVertices[i][1],
                        projectedVertices[i][2]
                    )
                );
            }

            var faceData;

            // faceData consists of two arrays - coordinates of mesh vertices in hyperbolic space and which 
            // vertices correspond to each face
            //
            // The coordinates are originally in the form of a row vector so transposes are required as well 
            // as multiplication by the f matrix to get them into the standard coordinates

            faceData = face(
                kleinVertices[faces[i][0]],
                kleinVertices[faces[i][1]],
                kleinVertices[faces[i][2]],
                n
            );

            // facets is the list of small trianglular faces that make up the mesh and which vertices make them up 
            var facets = faceData[0];
            var hyperboloidVertices = faceData[1];

            // transform the vertices to the appropriate model - poincare disk or hyperboloid model
            // scale them to the center
            // add them to the geometry
            for (var j = 0; j < hyperboloidVertices.length; j++) {

                var vertex = HF.kleinToPoincare(hyperboloidVertices[j]);
                var vertex2 = VF.vectorSum(VF.vectorScale(vertex, 1 - s), VF.vectorScale(kleinCenter, s));
                geometry.vertices.push(new THREE.Vector3(vertex2[0][0], vertex2[0][1], vertex2[0][2]));

            }

            // add the facets to the geometry

            for (var k = 0; k < facets.length; k++) {

                var facetPiece = facets[k];
                geometry.faces.push(new THREE.Face3(facetPiece[(transform.length) % 2], facetPiece[2], facetPiece[(transform.length + 1) % 2]));

            }

            for (var i = 0; i < cells.length; i++) {
                var facets = DATA.cellFaceDict[DATA.cells[cells[i]]];
                for (var j = 0; j < 8; j++) {
                    var facet = facets[j];
                    geometry.faces.push(
                        new THREE.Face3(
                            DATA.vertices.indexOf(facet[0]),
                            DATA.vertices.indexOf(facet[1]),
                            DATA.vertices.indexOf(facet[2])
                        )
                    );
                }
            }

            object = new THREE.Mesh(geometry, material);
            scene.add(object);

        }

        function face(a, b, c, n) {

            var j = 0;
            var coords = [a, b, c];
            var faces = [[0, 1, 2]];

            while (j < n) {

                var newCoords = [];
                var newFaces = [];

                for (var i = 0; i < faces.length; i++) {

                    var u = VF.midpoint([coords[faces[i][0]]], [coords[faces[i][1]]]);
                    var v = VF.midpoint([coords[faces[i][1]]], [coords[faces[i][2]]]);
                    var w = VF.midpoint([coords[faces[i][2]]], [coords[faces[i][0]]]);

                    newCoords = newCoords.concat([
                        coords[faces[i][0]],
                        coords[faces[i][1]],
                        coords[faces[i][2]],
                        u[0],
                        v[0],
                        w[0]
                    ]);

                    newFaces = newFaces.concat([
                        [6 * i, 6 * i + 3, 6 * i + 5],
                        [6 * i + 3, 6 * i + 1, 6 * i + 4],
                        [6 * i + 5, 6 * i + 4, 6 * i + 2],
                        [6 * i + 3, 6 * i + 4, 6 * i + 5]
                    ]);
                }

                faces = newFaces;
                coords = newCoords;
                j++;

            }

            return [faces, coords];
        }

        function rotateObject() {

            object.rotation.x -= 0;
            object.rotation.y -= 0.005;
            object.rotation.z -= 0.01;

        }

        function render() {

            requestAnimationFrame(render);
            rotateObject();
            renderer.render(scene, camera);

        }

        init([7, 8, 14, 15, 22, 23], 1);

        render();
    </script>

</body>

</html>