// ========================================================
// Order n dodecahderal truncated t{5,3,n}
// 
// Inputs: n
// Output: data
//
// Change history:
//     22/05/21 Initial commit
//     24/05/21 Renamed
//     01/06/21 Added v-v distance
//              Fixed metric
//=========================================================

import { rt5, p, p2, p3, p4, p5, p_1, p_2, p_3, p_4 } from "./constants.js";
import { boundaries } from "./geometry-decider.js";

const dodecahedronTruncData = (n) => {

    const metric = boundaries(n, Math.PI / Math.atan(p), Math.PI / Math.atan(p / Math.sqrt(5 * p4 + 1)));

    const cos = Math.cos(Math.PI / n) ** 2;
    const cot = cos / (1 - cos);

    const A = (p4 - 1) / 5;
    const B = 1 + 1 / rt5;
    const C = A / p;
    const D = B / p;
    const E = (1 - 1 / rt5) / 2;
    const F = (1 + 1 / rt5) / 2;
    const G = 1 / (p * rt5);

    const d =
        (n == 3) ? (v) => [
            (p * v[0] + v[1] * p_3 + v[3] * p_4) / 2,
            (p3 * v[0] - v[1] * p_1 - p * v[3]) / 2,
            v[2],
            (p2 * v[0] - p * v[1] + v[3]) / 2
        ] : (n == 4) ? (v) => [
            p2 * v[0] - v[1] - v[3] * p_1,
            p3 * v[0] - p * v[1] - p * v[3],
            v[2],
            p2 * v[0] - p * v[1]
        ] : (n == 5) ? (v) => [
            ((4 * p + 1) * v[0] - (4 * p - 1) * p_1 * v[1] - (4 * p - 1) * p_2 * v[3]) / 2,
            (p5 * v[0] + (2 - p4) * v[1] - p3 * v[3]) / 2,
            v[2],
            (p4 * v[0] - p3 * v[1] - v[3] * p_1) / 2
        ] : (n == 6) ? (v) => [
            ((2 + p4) * v[0] - p3 * v[1] - p2 * v[3]) / 2,
            (3 * p3 * v[0] + (2 - 3 * p2) * v[1] - 3 * p * v[3]) / 2,
            v[2],
            (3 * p2 * v[0] - 3 * p * v[1] - v[3]) / 2
        ] : (v) => [
            (2 * p * rt5 * cos - 1) * v[0] - (2 * rt5 * cos - 2 * p_1) * v[1] - (2 * rt5 * cos * p_1 - 2 * p_2) * v[3],
            2 * p3 * cos * v[0] + (1 - 2 * p2 * cos) * v[1] - 2 * p * cos * v[3],
            v[2],
            2 * p2 * cos * v[0] - 2 * p * cos * v[1] + (1 - 2 * cos) * v[3]
        ];

    const f = (v) => [
        p * Math.sqrt(Math.abs(cot / (1 + p_4 / 5 - p_2 * cot / 5))) * v[0],
        Math.sqrt(Math.abs((cot - p_2) / (1 + p_4 / 5 - p_2 * cot / 5))) * v[1],
        Math.sqrt(Math.abs((cot - p_2) / (1 + p_4 / 5 - p_2 * cot / 5))) * v[2],
        Math.sqrt(Math.abs((cot - p_2) / (1 + p_4 / 5 - p_2 * cot / 5))) * v[3]
    ];

    return {

        vertices: [
            [1, B, C, -E], [1, B, C, E], [1, p, G, 0],
            [1, p, -G, 0], [1, B, -C, -E], [1, B, -C, E],
            [1, F, -A, D], [1, A, -D, F], [1, D, -F, A],
            [1, C, -E, B], [1, C, E, B], [1, G, 0, p],
            [1, D, F, A], [1, A, D, F], [1, F, A, D],
            [1, E, B, C], [1, 0, p, G], [1, -E, B, C],
            [1, -F, A, D], [1, -A, D, F], [1, -D, F, A],
            [1, -C, E, B], [1, -G, 0, p], [1, -C, -E, B],
            [1, -D, -F, A], [1, -A, -D, F], [1, -F, -A, D],
            [1, -E, -B, C], [1, E, -B, C], [1, 0, -p, G],
            [1, 0, -p, -G], [1, E, -B, -C], [1, -E, -B, -C],
            [1, F, -A, -D], [1, A, -D, -F], [1, D, -F, -A],
            [1, C, -E, -B], [1, G, 0, -p], [1, C, E, -B],
            [1, D, F, -A], [1, F, A, -D], [1, A, D, -F],
            [1, E, B, -C], [1, -E, B, -C], [1, 0, p, -G],
            [1, -B, C, -E], [1, -B, C, E], [1, -p, G, 0],
            [1, -p, -G, 0], [1, -B, -C, E], [1, -B, -C, -E],
            [1, -A, -D, -F], [1, -F, -A, -D], [1, -D, -F, -A],
            [1, -C, -E, -B], [1, -G, 0, -p], [1, -C, E, -B],
            [1, -D, F, -A], [1, -F, A, -D], [1, -A, D, -F]
        ],

        edges: [
            [0, 1], [0, 2], [0, 41], [1, 2], [1, 13],
            [2, 3], [3, 4], [3, 5], [4, 5], [4, 34],
            [5, 7], [6, 7], [6, 8], [6, 28], [7, 8],
            [8, 9], [9, 10], [9, 11], [10, 11], [10, 12],
            [11, 22], [12, 13], [12, 14], [13, 14], [14, 15],
            [15, 16], [15, 17], [16, 17], [16, 44], [17, 18],
            [18, 19], [18, 20], [19, 20], [19, 46], [20, 21],
            [21, 22], [21, 23], [22, 23], [23, 24], [24, 25],
            [24, 26], [25, 26], [25, 49], [26, 27], [27, 28],
            [27, 29], [28, 29], [29, 30], [30, 31], [30, 32],
            [31, 32], [31, 33], [32, 52], [33, 34], [33, 35],
            [34, 35], [35, 36], [36, 37], [36, 38], [37, 38],
            [37, 55], [38, 39], [39, 40], [39, 41], [40, 41],
            [40, 42], [42, 43], [42, 44], [43, 44], [43, 58],
            [45, 46], [45, 47], [45, 59], [46, 47], [47, 48],
            [48, 49], [48, 50], [49, 50], [50, 51], [51, 52],
            [51, 53], [52, 53], [53, 54], [54, 55], [54, 56],
            [55, 56], [56, 57], [57, 58], [57, 59], [58, 59]
        ],

        faces: [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13, 14],
            [15, 16, 17], [18, 19, 20], [21, 22, 23], [24, 25, 26], [27, 28, 29],
            [30, 31, 32], [33, 34, 35], [36, 37, 38], [39, 40, 41], [42, 43, 44],
            [45, 46, 47], [48, 49, 50], [51, 52, 53], [54, 55, 56], [57, 58, 59],
            [0, 1, 13, 14, 15, 16, 44, 42, 40, 41], [1, 2, 3, 5, 7, 8, 9, 10, 12, 13],
            [0, 2, 3, 4, 34, 35, 36, 38, 39, 41], [10, 11, 22, 21, 20, 18, 17, 15, 14, 12],
            [4, 5, 7, 6, 28, 29, 30, 31, 33, 34], [6, 8, 9, 11, 22, 23, 24, 26, 27, 28],
            [25, 26, 27, 29, 30, 32, 52, 51, 50, 49], [31, 32, 52, 53, 54, 55, 37, 36, 35, 33],
            [37, 38, 39, 40, 42, 43, 58, 57, 56, 55], [16, 17, 18, 19, 46, 45, 59, 58, 43, 44],
            [19, 20, 21, 23, 24, 25, 49, 48, 47, 46], [45, 47, 48, 50, 51, 53, 54, 56, 57, 59]
        ],

        numVertices: 60,

        numEdges: 90,

        numFaces: 32,

        // CFE
        // (0, 0, 1, 0)
        a: (v) => [v[0], v[1], -v[2], v[3]],
        // CFV
        // (0, 1, -p ** 2, p)
        b: (v) => [v[0], (p * v[1] + v[2] + v[3] * p_1) / 2, (v[1] - v[2] * p_1 - p * v[3]) / 2, (v[1] * p_1 - p * v[2] + v[3]) / 2],

        // CEV
        // (0, 0, 0, 1)
        c: (v) => [v[0], v[1], v[2], -v[3]],

        // FEV
        // ?????
        d: d,

        e: (v) => v,

        f: f,

        faceReflections: [""],

        outerReflection: "d",

        // (1, p, 1 / p, 0)
        V: [1, p, p_1, 0],

        // (1, p, 0, 0)
        E: [1, p, 0, 0],

        // (3 - p, p, 0, 1)
        F: [3 - p, p, 0, 1],

        // (1, 0, 0, 0)
        C: [1, 0, 0, 0],

        // 3 4 5 6 7
        // s h h p u
        metric: metric,

        cellType: "spherical",

        vv: (p_2 * cot / 5 + 3 * p / 5) / Math.abs(1 + p_4 / 5 - p_2 * cot / 5)

    }

}

export { dodecahedronTruncData };