<!DOCTYPE html>
<html>

    <head>

        <meta charset="utf-8">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
        <script type="text/javascript" async
            src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
            </script>
        <script>
            $(function () {
                $("#side-menu").load("./menu-bars.html");
                MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            });
        </script>

        <link rel="stylesheet" href="../css/test.css">

        <title>sHapES</title>
    </head>

    <body>

        <div id="side-menu"></div>

        <script type="module">

            import * as MAIN from "../js/main/main-utilities.js";
            import * as THREE from "../js/three-bits/three.module.js";

            import { tetrahedronData } from "../js/data/33n.js";
            import { octahedronData } from "../js/data/34n.js";
            import { icosahedronData } from "../js/data/35n.js";
            import { cubeData } from "../js/data/43n.js";
            import { dodecahedronData } from "../js/data/53n.js";
            import { hexagonData } from "../js/data/63n.js";
            import { squareData } from "../js/data/44n.js";
            import { triangleData } from "../js/data/36n.js";

            import { MapControls } from "../js/three-bits/orbit-controls.js";
            import * as CONSTANTS from "../js/main/main-constants.js";

            var view = document.getElementById("view");
            var WIDTH = view.clientWidth;
            var HEIGHT = view.clientHeight;
            var rect = view.getBoundingClientRect();

            // constants for canvas
            // s = scale of arrangement
            // rotatePositions = where the shapes rotate
            const s = 3;
            const rotatePositions = CONSTANTS.rotatePositions(s);

            // setup scene
            var scene = new THREE.Scene();
            scene.background = new THREE.Color(0xDDDDDD);

            // group of meshes
            var meshes = new THREE.Group();

            // add camera and light to scene
            var camera = new THREE.PerspectiveCamera(70, WIDTH / HEIGHT, 0.1, 100);
            camera.position.set(3.5 * s, s, -4 * s);
            camera.up = new THREE.Vector3(0, -1, 0);
            camera.updateProjectionMatrix();
            camera.add(new THREE.HemisphereLight(0xaaaaaa, 0x555555));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(3.5 * s, s, -4 * s);
            camera.add(directionalLight);
            scene.add(camera);
            scene.add(new THREE.HemisphereLight(0xcccccc, 0x222222));

            // add the polyhedrons to the scene

            const geom = {
                "{3,5}": icosahedronData,
                "{5,3}": dodecahedronData,
                "{4,3}": cubeData,
                "{3,3}": tetrahedronData,
                "{3,4}": octahedronData,
                "{6,3}": hexagonData,
                "{4,4}": squareData,
                "{3,6}": triangleData
            };

            CONSTANTS.names.forEach((name) => {

                const order = [
                    parseInt(name.split(",")[0].replace("{", "")),
                    parseInt(name.split(",")[1]),
                    parseInt(name.split(",")[2].replace("}", ""))
                ];

                const data = geom["{" + order[0].toString() + "," + order[1].toString() + "}"];
                const mainData = ((order[0] - 2) * (order[1] - 2) <= 4) ? data(order[2]) : data(order[0], order[1], order[2]);

                MAIN.addCellToGroup({
                    data: mainData,
                    group: meshes,
                    refinement: CONSTANTS.mainDefinition,
                    colour: "0xFFFFFF",
                    position: rotatePositions[name],
                    name: name,
                    transform: "",
                    model: "poincare"
                });

            })

            // setup the renderer
            var renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(WIDTH, HEIGHT);
            var intersectionObjectName, intersectionObject, clickObjectParams;

            // add controls to the camera
            var controls = new MapControls(camera, renderer.domElement);
            controls.enableZoom = true;
            controls.enableRotate = false;
            controls.screenSpacePanning = true;
            controls.target = new THREE.Vector3(3.5 * s, s, 0);
            controls.enabled = true;
            controls.minZoom = s;
            controls.maxZoom = 3 * s;

            var minPan = new THREE.Vector3(0, -s, 0);
            var maxPan = new THREE.Vector3(7 * s, 2 * s, 0);
            var _v = new THREE.Vector3();

            controls.addEventListener("change", function () {
                _v.copy(controls.target);
                controls.target.clamp(minPan, maxPan);
                _v.sub(controls.target);
                camera.position.sub(_v);
            });

            controls.update();

            // add a raycaster to the scene for object selection
            var raycaster = new THREE.Raycaster(), mouseVector = new THREE.Vector2();

            // add the meshes to the scene
            scene.add(meshes);

            // add some event listeners
            window.addEventListener("click", onMouseClick, false);
            window.addEventListener("mousemove", onMouseMove, false);
            window.addEventListener("resize", onWindowResize, false);

            view.addEventListener('touchstart', touchStart, false);
            view.addEventListener('touchend', touchEnd, false);

            // add the renderer to the 'view' div
            view.appendChild(renderer.domElement);

            render();

            // t is time and is used in rotations
            // click Object is the object clicked by the user
            var t = 0, clickObject = "";

            function render() {

                requestAnimationFrame(render);

                meshes.children.forEach(element => {
                    element.rotation.y = t * 0.003;
                    element.rotation.y = -t * 0.005;
                    element.rotation.z = -t * 0.007;
                });
                t++;

                renderer.render(scene, camera);

            }

            function onMouseClick(event) {

                var rect = view.getBoundingClientRect();

                mouseVector.x = ((event.clientX - rect.left) / WIDTH) * 2 - 1;
                mouseVector.y = - ((event.clientY - rect.top) / HEIGHT) * 2 + 1;
                raycaster.setFromCamera(mouseVector, camera);

                var intersects = raycaster.intersectObjects(meshes.children);
                if (intersects.length != 0) {
                    var obj = intersects[0].object;
                    console.log(obj);
                    window.location = CONSTANTS.shapeLinks[obj.name];
                } else {
                    console.log("empty space");
                    clickObject = null;
                    document.getElementById("content1").innerHTML = "empty space";
                }

            }

            function onWindowResize(event) {

                WIDTH = view.clientWidth;
                HEIGHT = view.clientHeight;
                renderer.setSize(WIDTH, HEIGHT);
                camera.aspect = WIDTH / HEIGHT;
                camera.updateProjectionMatrix();

            }

            function touchStart(e) {

                e.preventDefault();

            }

            function touchEnd(e) {

                var rect = view.getBoundingClientRect();

                e.preventDefault();

                var touches = e.changedTouches;

                mouseVector.x = ((touches[0].clientX - rect.left) / WIDTH) * 2 - 1;
                mouseVector.y = - ((touches[0].clientY - rect.top) / HEIGHT) * 2 + 1;
                raycaster.setFromCamera(mouseVector, camera);

                var intersects = raycaster.intersectObjects(meshes.children);
                if (intersects.length != 0) {
                    var obj = intersects[0].object;
                    console.log(obj);
                    window.location = CONSTANTS.shapeLinks[obj.name];
                } else {
                    clickObject = null;
                    document.getElementById("content1").innerHTML = "empty space";
                }
            }

            function onMouseMove(event) {

                event.preventDefault();

                var rect = view.getBoundingClientRect();

                mouseVector.x = ((event.clientX - rect.left) / WIDTH) * 2 - 1;
                mouseVector.y = - ((event.clientY - rect.top) / HEIGHT) * 2 + 1;
                raycaster.setFromCamera(mouseVector, camera);

                var intersects = raycaster.intersectObjects(meshes.children);

                if (intersects.length > 0) {
                    document.getElementById("content1").innerHTML = intersects[0].object.name;
                    if (intersectionObjectName != intersects[0].object.name) {
                        intersectionObjectName = intersects[0].object.name;
                        meshes.children.forEach(mesh => {
                            if (mesh.name === intersectionObjectName) {
                                var col = {
                                    r: mesh.material.color.r,
                                    g: mesh.material.color.g,
                                    b: mesh.material.color.b
                                };
                                mesh.material.emissive.setRGB(col.r, col.g, col.b);
                            } else {
                                mesh.material.emissive.setRGB(0, 0, 0);
                            }
                        });
                    }
                } else {
                    document.getElementById("content1").innerHTML = document.getElementById("content1").innerHTML;
                    meshes.children.forEach(mesh => { mesh.material.emissive.setRGB(0, 0, 0); });
                    intersectionObjectName = null;
                }
            }

        </script>

        <div id="view"></div>

    </body>

</html>
