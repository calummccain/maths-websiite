<canvas width="800" height="400"></canvas>

<script type="module">

    import * as DATA from "../js/data/hyperbolic/35n.js";
    import * as HF from "../js/maths-functions/hyperbolic-functions.js";
    import * as VF from "../js/maths-functions/vector-functions.js";

    let canvas = document.querySelector("canvas");
    let context = canvas.getContext("2d");

    const camera = 3;
    const plane = 2;
    const scale = 700;
    var poinVert = [];
    var dataPoints = [];
    var lines = [];
    var t = 0;
    var norms = [];


    DATA.vertices.forEach((vert) => {
        const poin = DATA.f(3, vert);
        dataPoints.push(poin);
    })

    console.log("dataPoints", dataPoints)

    function findPerp() {

        DATA.lines.forEach((edge) => {
            var a = HF.hyperboloidToPoincare(dataPoints[edge[0]]);
            var b = HF.hyperboloidToPoincare(dataPoints[edge[1]]);
            var norm = [
                a[1] * b[2] - a[2] * b[1], 
                a[2] * b[0] - a[0] * b[2], 
                a[0] * b[1] - a[1] * b[0]
            ];
            norms.push(norm);

        })

    }

    findPerp();
    console.log("norms", norms);

    window.requestAnimationFrame(draw);

    function makeEdges(iMax) {

        DATA.lines.forEach((edge) => {

            var i = 0;
            var hypVerts = [dataPoints[edge[0]], dataPoints[edge[1]]];

            while (i < iMax) {
                var newHypVerts = [];
                for (var j = 0; j < hypVerts.length - 1; j++) {
                    newHypVerts.push(hypVerts[j]);
                    var sum = VF.vectorSum(hypVerts[j], hypVerts[j + 1]);
                    newHypVerts.push(VF.vectorScale(sum, 1 / Math.sqrt(HF.hyperbolicNorm(sum))));
                    newHypVerts.push(hypVerts[j + 1]);
                }
                hypVerts = newHypVerts;
                i++
            }
            var poinVerts = [];
            hypVerts.forEach((vert) => { poinVerts.push(HF.hyperboloidToPoincare(vert)) })
            lines.push(poinVerts);
        })
    }

    makeEdges(3);
    console.log(lines)

    function line(edge, can) {
        if (edge.length > 0) {
            can.beginPath();
            can.moveTo(edge[0][0], edge[0][1]);
            can.lineWidth = 3;
            for (var i = 1; i < edge.length; i++) {
                can.lineTo(edge[i][0], edge[i][1]);
            }
            can.stroke();
        }
    }

    function draw() {

        context.clearRect(0, 0, canvas.width, canvas.height); // clear canvas

        var sin = Math.sin(2 * Math.PI * t / 800);
        var cos = Math.cos(2 * Math.PI * t / 800);

        lines.forEach((edge) => {
            var rotateAndProject = [];
            edge.forEach((vert) => {
                var xr = vert[0];
                var yr = vert[1] * cos - vert[2] * sin;
                var zr = vert[1] * sin + vert[2] * cos;
                if (zr >= -1) {
                    var xScale = xr * (camera - plane) / (camera - zr);
                    var yScale = yr * (camera - plane) / (camera - zr);
                    var x = scale * xScale + (canvas.width / 2);
                    var y = scale * yScale + (canvas.height / 2);
                    rotateAndProject.push([x, y]);
                }
            })
            line(rotateAndProject, context);
        })
        t += 1
        poinVert = [];
        //window.requestAnimationFrame(draw);
    }

</script>
