<!DOCTYPE html>
<html>

    <head>

        <meta charset="utf-8">

        <link rel="stylesheet" href="../css/test.css">

        <title>first page</title>
    </head>

    <body>

        <a href="/root/index.html">index</a>

        <script type="module">

            import * as THREE from "../js/three.module.js";
            import { OrbitControls } from "../js/orbit-controls.js";

            var WIDTH = window.innerWidth;
            var HEIGHT = window.innerHeight;

            const div_r = 2;
            const div_theta = 20;
            const div_phi = 20;
            const div_mu = 6;
            const div_nu = 20;
            //const div_phi = 10;

            const scale = 100;

            var scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc);

            // Orthographic
            //var camera = new THREE.OrthographicCamera(WIDTH / - 2, WIDTH / 2, HEIGHT / 2, HEIGHT / - 2, 1, 100);

            // Perspective
            var camera = new THREE.PerspectiveCamera(70, WIDTH / HEIGHT, 1, 1000);
            camera.position.set(50, 50, 50);
            camera.up = new THREE.Vector3(0, 0, -1);

            scene.add(camera);
            scene.add(new THREE.HemisphereLight(0xcccccc, 0x222222));

            var renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(WIDTH, HEIGHT);

            var controls = new OrbitControls(camera, renderer.domElement);
            controls.update();

            var geometry = new THREE.BufferGeometry();
            var vertices = [];

            // var r, theta, phi;

            // for (var i = 1; i <= div_r; i++) {

            //     r = scale * i / div_r;

            //     for (var j = 0; j <= div_theta; j++) {

            //         theta = Math.PI * j / div_theta;

            //         for (var k = 0; k <= div_phi; k++) {

            //             phi = 2 * Math.PI * k / div_phi;

            //             var x = r * Math.sin(theta) * Math.cos(phi);
            //             var y = r * Math.sin(theta) * Math.sin(phi);
            //             var z = r * Math.cos(theta);

            //             vertices.push(x, y, z);
            //         }

            //     }

            // }

            var mu, nu, phi;

            for (var i = 5; i <= div_mu; i++) {

                mu = i / div_mu;

                for (var j = 0; j <= div_nu; j++) {

                    nu = Math.PI * j / div_nu - Math.PI / 2;

                    for (var k = 0; k <= div_phi; k++) {

                        phi = 2 * Math.PI * k / div_phi - Math.PI;

                        var x = scale * Math.cosh(mu) * Math.cos(nu) * Math.cos(phi);
                        var y = scale * Math.cosh(mu) * Math.cos(nu) * Math.sin(phi);
                        var z = scale * Math.sinh(mu) * Math.sin(nu);

                        vertices.push(x, y, z);
                    }

                }

            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            var material = new THREE.PointsMaterial({ size: 3, sizeAttenuation: true });
            material.color.setHSL(Math.random(), Math.random(), Math.random());

            var particles = new THREE.Points(geometry, material);
            scene.add(particles);

            document.body.appendChild(renderer.domElement);

            render();

            function render() {

                requestAnimationFrame(render);

                controls.update();
                renderer.render(scene, camera);

            }

        </script>

    </body>

</html>
