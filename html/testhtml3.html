<canvas width="1440" height="720"></canvas>

<script type="module">

    import * as DATA from "../js/data/hyperbolic/35n.js";
    import * as HF from "../js/maths-functions/hyperbolic-functions.js";
    import * as VF from "../js/maths-functions/vector-functions.js";

    let canvas = document.querySelector("canvas");
    let context = canvas.getContext("2d");

    const camera = 2500;
    const plane = 600;
    const scale = 30;
    var vertices = [];
    var hypPoints = [];
    var visible = [];
    var t = 0;
    var radius = 0;
    var rotateAndProject = [];
    var center = [];
    var centers = [[1, 0, 0, 0]];

    // getHypPoints("dcad");
    // getCenter();
    // console.log(center)
    // makeEdges(4);
    // visibility();

    const t1 = firstLayer();
    const t2 = secondLayer();

    draw("", [20, 20]);

    function matrixDict(letter, vector) {
        return DATA.matrixDict(3, letter, vector);
    }

    function secondLayer() {
        var trans = [];
        const eps = 1e-3;

        for (var i = 0; i < 20; i++) {
            for (var j = 0; j < 20; j++) {
                var testCenter = HF.transformVertices([[1, 0, 0, 0]], DATA.faceReflections[i] + "d" + DATA.faceReflections[j] + "d", matrixDict)[0];
                var good = true;
                for (var k = 0; k < centers.length; k++) {
                    good = good && (!(
                        (Math.abs(centers[k][0] - testCenter[0]) < eps) &&
                        (Math.abs(centers[k][1] - testCenter[1]) < eps) &&
                        (Math.abs(centers[k][2] - testCenter[2]) < eps) &&
                        (Math.abs(centers[k][3] - testCenter[3]) < eps)
                    ))
                }
                if (good) {
                    trans.push(DATA.faceReflections[i] + "d" + DATA.faceReflections[j] + "d");
                    centers.push(testCenter);
                }
            }
        }
        return trans;
    }

    function firstLayer() {
        var trans = [];
        const eps = 1e-3;

        for (var i = 0; i < 20; i++) {
            var testCenter = HF.transformVertices([[1, 0, 0, 0]], DATA.faceReflections[i] + "d", matrixDict)[0];
            var done = false;
            while (!done) {
                for (var k = 0; k < centers.length; k++) {
                    if (
                        (Math.abs(centers[k][0] - testCenter[0]) < eps) &&
                        (Math.abs(centers[k][1] - testCenter[1]) < eps) &&
                        (Math.abs(centers[k][2] - testCenter[2]) < eps) &&
                        (Math.abs(centers[k][3] - testCenter[3]) < eps)
                    ) {
                        done = true;
                    }
                }
                trans.push(DATA.faceReflections[i] + "d");
                centers.push(testCenter);
                done = true;
            }
        }
        return trans;
    }

    // console.log(firstLayer());
    // console.log(centers);
    // console.log(secondLayer());
    console.log(t2)

    for (var word = 1; word <= t2.length; word++) {

        console.log(word, t2[word - 1])

        draw(t2[word - 1], [60 * (word % 20) + 20, 60 * (word - word % 20) / 20 + 20]);

    }

    function getHypPoints(transform) {

        const data = HF.transformVertices(DATA.vertices, transform, matrixDict);

        data.forEach((vert) => {

            const poin = DATA.f(3, vert);
            hypPoints.push(poin);
        })

    }

    function getCenter() {

        var hypCenter = [0, 0, 0, 0];

        hypPoints.forEach((vert) => {
            hypCenter = VF.vectorSum(hypCenter, vert);
        })

        hypCenter = VF.vectorScale(hypCenter, 1 / Math.sqrt(HF.hyperbolicNorm(hypCenter)));
        center = HF.hyperboloidToPoincare(hypCenter);

        for (var j = 0; j < hypPoints.length - 1; j++) {

            radius = Math.max(radius, VF.norm(VF.vectorDiff(HF.hyperboloidToPoincare(hypPoints[j]), center)));

        }

    }


    function makeEdges(iMax) {

        for (var line in DATA.lines) {

            var i = 0;
            var hypVerts = [hypPoints[DATA.lines[line][0]], hypPoints[DATA.lines[line][1]]];

            while (i < iMax) {

                var newHypVerts = [];

                for (var j = 0; j < hypVerts.length - 1; j++) {

                    newHypVerts.push(hypVerts[j]);
                    var sum = VF.vectorSum(hypVerts[j], hypVerts[j + 1]);
                    newHypVerts.push(VF.vectorScale(sum, 1 / Math.sqrt(HF.hyperbolicNorm(sum))));

                }

                newHypVerts.push(hypVerts[hypVerts.length - 1]);
                hypVerts = newHypVerts;
                i++;

            }

            var poinVerts = [];
            hypVerts.forEach((vert) => { poinVerts.push(VF.vectorScale(VF.vectorDiff(HF.hyperboloidToPoincare(vert), center), scale / radius)) });
            vertices = vertices.concat(poinVerts);

        }

    }

    function rayTriangleIntersect(origin, direction, v1, v2) {

        var dir = VF.vectorScale(direction, 1 / VF.norm(direction));
        var eps = 1e-2;
        var h = VF.vectorCross(dir, v2);
        var a = VF.vectorDot(v1, h);

        if (Math.abs(a) < eps) {

            return false;

        }

        var f = 1 / a;
        var u = f * VF.vectorDot(origin, h);

        if (u < 0 || u > 1) {

            return false;

        }

        var q = VF.vectorCross(origin, v1);
        var v = f * VF.vectorDot(dir, q);

        if (v < 0 || u + v > 1) {

            return false;

        }

        var t = f * VF.vectorDot(v2, q) / VF.norm(direction);

        if (t < 1) {

            return true;

        }

        return false;

    }


    function isPointVisible(cameraPos, targetPos) {

        const factor = 1.01;
        const aim = VF.vectorScale(targetPos, factor);
        const dir = VF.vectorDiff(aim, cameraPos);
        var vis = true;

        const numero = vertices.length / 30;

        for (var i = 0; i < 30; i++) {

            for (var j = 0; j < numero - 1; j++) {

                vis *= !(rayTriangleIntersect(cameraPos, dir, vertices[i * numero + j], vertices[i * numero + j + 1]));

            }

        }

        return vis;

    }

    function visibility() {

        for (var i = 0; i < vertices.length; i++) {
            visible.push(isPointVisible([0, 0, camera], vertices[i]));
        }

    }

    function drawLine(hidden) {

        const numero = vertices.length / 30;

        if (hidden) {

            for (var i = 0; i < 30; i++) {

                for (var j = 0; j < numero - 1; j++) {

                    if (!(visible[i * numero + j] && visible[i * numero + j + 1])) {
                        context.strokeStyle = '#AAAAAA';
                        context.beginPath();
                        context.moveTo(rotateAndProject[i * numero + j][0], rotateAndProject[i * numero + j][1]);
                        context.lineWidth = 1;
                        context.lineTo(rotateAndProject[i * numero + j + 1][0], rotateAndProject[i * numero + j + 1][1]);
                        context.stroke();
                    }

                }

            }

        }

        for (var i = 0; i < 30; i++) {

            for (var j = 0; j < numero - 1; j++) {

                if (visible[i * numero + j] && visible[i * numero + j + 1]) {
                    context.strokeStyle = '#000000';
                    context.beginPath();
                    context.moveTo(rotateAndProject[i * numero + j][0], rotateAndProject[i * numero + j][1]);
                    context.lineWidth = 1;
                    context.lineTo(rotateAndProject[i * numero + j + 1][0], rotateAndProject[i * numero + j + 1][1]);
                    context.stroke();
                }

            }

        }

    }


    function draw(transform, translate) {

        vertices = [];
        hypPoints = [];
        visible = [];
        t = 0;
        rotateAndProject = [];
        center = [];
        radius = 0;

        getHypPoints(transform);
        getCenter();
        makeEdges(4);
        visibility();

        rotateAndProject = [];
        //context.clearRect(0, 0, canvas.width, canvas.height); // clear canvas

        var sin = Math.sin(2 * Math.PI * t / 800);
        var cos = Math.cos(2 * Math.PI * t / 800);

        const numero = vertices.length / 30;

        for (var i = 0; i < 30; i++) {

            for (var j = 0; j < numero; j++) {

                var vert = vertices[i * numero + j]

                var xr = vert[0];
                var yr = vert[1] * cos - vert[2] * sin;
                var zr = vert[1] * sin + vert[2] * cos;
                var xScale = xr * (camera - plane) / (camera - zr);
                var yScale = yr * (camera - plane) / (camera - zr);
                var x = xScale + translate[0];
                var y = yScale + translate[1];
                rotateAndProject.push([x, y]);

            }

        }

        drawLine(false);

    }

</script>
